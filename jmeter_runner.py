import sys
import subprocess
import os
import shlex

def run_jmeter_command(jmeter_bin_path, command_string):
    """
    Executes the provided JMeter command string.

    Args:
        jmeter_bin_path (str): The path to the JMeter 'bin' directory.
        command_string (str): The full JMeter command line string to execute.

    Returns:
        tuple: (status_code, message, report_path)
               status_code: 0 for success, 1 for failure.
               message: Output/error message.
               report_path: Path to the generated report directory on success, else None.
    """
    report_path = None
    try:
        # Ensure the command uses the correct jmeter executable from the path
        # The command string from OpenAI should already contain the full path,
        # but we can double-check or reconstruct if needed.
        # For robustness, let's assume command_string might just have 'jmeter'
        # and prepend the path if necessary.

        # A safer way to handle paths with spaces is to split the command correctly
        try:
             args = shlex.split(command_string)
        except ValueError as e:
             return 1, f"Error parsing command string: {e}. Command: '{command_string}'", None


        # Find the jmeter executable part and ensure it uses the provided path
        jmeter_executable = os.path.join(jmeter_bin_path, 'jmeter')
        if args[0] != jmeter_executable:
             # If the command starts with just 'jmeter' or a different path, replace it
             if os.path.basename(args[0]) == 'jmeter':
                 args[0] = jmeter_executable
             else:
                 # Or maybe raise an error if the command seems incorrect
                 print(f"Warning: Command string might not use the correct JMeter path. Provided: {jmeter_bin_path}, Command starts with: {args[0]}")
                 # For now, we'll proceed assuming the command string is correct as generated by AI

        print(f"Executing command: {' '.join(args)}") # Log the command being run

        # Extract the report directory from the command arguments
        try:
            report_index = args.index('-o') + 1
            if report_index < len(args):
                report_path = args[report_index]
                # Create the report directory beforehand if it doesn't exist
                # JMeter usually requires the parent directory to exist.
                # The -e flag creates the specified dir, but let's be safe.
                os.makedirs(os.path.dirname(report_path), exist_ok=True)
            else:
                 raise ValueError("Missing report directory path after -o flag.")
        except ValueError:
            print("Warning: Could not find or parse report directory path ('-o') in the command.")
            report_path = None # Cannot determine report path

        # Execute the command
        process = subprocess.run(args, capture_output=True, text=True, check=False) # check=False to handle errors manually

        if process.returncode == 0:
            print("JMeter execution successful.")
            print(f"Stdout:\n{process.stdout}")
            return 0, process.stdout, report_path
        else:
            print(f"JMeter execution failed with code {process.returncode}.")
            print(f"Stderr:\n{process.stderr}")
            print(f"Stdout:\n{process.stdout}")
            error_message = process.stderr if process.stderr else process.stdout
            return 1, f"JMeter failed: {error_message}", None

    except FileNotFoundError:
        error_msg = f"Error: JMeter executable not found at '{jmeter_executable}'. Please check the JMeter path."
        print(error_msg)
        return 1, error_msg, None
    except Exception as e:
        error_msg = f"An unexpected error occurred: {e}"
        print(error_msg)
        return 1, error_msg, None

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python jmeter_runner.py <jmeter_bin_path> \"<full_jmeter_command>\"")
        sys.exit(1)

    jmeter_path_arg = sys.argv[1]
    command_arg = sys.argv[2]

    status_code, output_msg, final_report_path = run_jmeter_command(jmeter_path_arg, command_arg)

    # Output for the calling script (app.py) to capture
    if status_code == 0:
        print(f"Status: success")
        print(f"Report Path: {final_report_path}")
        print(f"Output: {output_msg}") # Include JMeter output
    else:
        print(f"Status: error")
        print(f"Message: {output_msg}")

    sys.exit(status_code) # Exit with the status code
